# 11월 27일 코드 리뷰 면접 내용

- 회사명: 인******
- 면접 날짜: 11월 27일 금요일
- 면접 형태: 기술 면접 (코드리뷰), Microsoft Teams 를 이용한 화상 면접, 4:1

> 포트폴리오(프로젝트)를 소개하고 해당 코드를 직접 리뷰하며 질의를 받는식으로 진행했습니다.
> 사전에 안내된 일정이 있긴 했지만, 면접 시작하자마자 자기소개 없이 포트폴리오 소개를 요청하셨고, 30분 동안 코드를 설명하고 중간중간에 계속 질문을 받고 답하는 식으로 면접이 진행되었습니다.
>
> 이번에 면접에서 소개한 프로젝트는 '천재교육'에서 진행했던 GENIE 프로젝트입니다.
> 해당 프로젝트는 AI 를 이용한 지문 및 문항 생성 서비스이며, 면접에서 '인증 방식'을 코드 리뷰할지, '지문/문항 생성 비즈니스 로직'을 코드 리뷰할지 여쭈어보았고, 그 결과 '인증 방식'에 대한 코드 리뷰를 진행하게 되었습니다.
> 
> 아래 내용은 코드 리뷰를 진행하며 받았던 질문 리스트와 저의 답변, 그리고 아쉬웠던 점 등을 정리해 보았습니다.
> 알고있는 내용이지만 면접상황에서 용어가 생각나지 않기도 하고, 더 잘 답변할 수도 있었는데, 질문을 너무 단편적으로 생각했던 부분들이 많았네요.

'질문 리스트'와 '답변 내용'은 코드 리뷰 면접상황을 복기한 것으로 일부 내용이 빠지거나 생략되었습니다.

## 질문 + 나의 답변

1. HttpServletRequest request 에는 무엇이 있는가?
- jwt 토큰, 사용자의 ip 주소, 사용자가 보내는 데이터 request 데이터 같은 것들이... 들어있습니다.

2. @Component 어노테이션은 무엇인지 아느냐?
- Spring 에서 bean을 등록해줄 때 사용하는 어노테이션 입니다. new로 객체를 생성하는 대신에 미리 해당 객체를 만들어두고 재사용하기 위해 사용됩니다.

3. @Component 쓰는거랑 new를 쓰는거의 차이를 아느냐?
- new를 사용하게되면 사용자 요청이 들어올 때마다 새로운 객체를 만들어 실행되지만, bean으로 등록한 객체를 이용하게되면 해당 객체를 각 요청에서 재사용하고 멀티스레드에서 실행시켜준다고 알고있습니다.
- 아쉬운 점: 결국 생명주기 얘기만 하면 되는 문제인건데.. 너무 오랜만에 생각하다 보니 정확한 답변을 하지 못했던 것 같네요.

3. 토큰이 유효한지 어떻게 체크하는지 알고있느냐?
- jwt 토큰 비밀키를 이용해 사용자를 검증하고 있습니다. 그리고 access 토큰과 refresh 토큰을 이용해 사용자 인증을 확인합니다.
  (이건 면접관의 질문 의도와 다른 답이었다고 함. 어떤 코드에서 어떻게 체크하는지를 아는지 물어본 것이었음)

4. 토큰 유효시간은 어떻게 설정했느냐?
- private.properties 파일에서 access토큰은 1시간, refresh 토큰은 1주일로 설정해뒀습니다.

5. access 토큰은 왜 1시간으로 설정했느냐, refresh 토큰은 왜 1주일로 했느냐?
- 서비스를 이용하는 동안 사용자가 잠시 자리를 비울 수도 있고, 사용자 경험을 향상시키기 위해 1시간정도로 잡았습니다.
- refresh 토큰은 보안상 1주일로 설정해뒀습니다.

6. refresh 토큰이 1주일이면 안전한거냐? 1주일로 설정한 근거가 무엇이냐
- 너무 짧으면 사용자 경험이 떨어질 수 있고, 너무 길면 그래도 해킹 위험에 더 장시간 노출될 수 있어서..
- 아쉬운 점: 개선 방향을 제시하면 좋았을 텐데.. 예를 들면 블랙리스트 관리에 대해 얘기한다던지, refresh 토큰도 자주 갱신을 해주면 된다라는 식으로?

7. @AuthenticationPrincipal 이건 왜 api endpoint마다 입력해서 사용하느냐 (JWT Filter 에서 SecurityContext에 memberId를 이용해 DB에서 조회한 사용자 데이터를 넣어주고 있었음)
- db에 데이터를 저장할 때 실제 사용자임을 확인하기 위해 넣었습니다.

8. 굳이 필요 없어 보이는데 넣어둔 이유가 뭐냐, 어짜피 로그인 인증 받는데 굳이 이게 있을 필요가 있느냐
- 아무리 인증을 받았다고 하더라도.. 비즈니스 로직에서도 확인이 필요하지 않을까요...?
- 아쉬운 점: 지금 생각해보니 id도 들어오는데 굳이 db 조회를 다시 할 필요가 있나 싶다. (바로 코드 리팩토링 진행함)

9. 데이터 생성에 post 요청을 사용한 이유가 무엇이냐
- get으로도 요청을 보내는게 가능하긴 하지만, 데이터 생성에 있어서 긴 데이터를 저장하는 경우에 body에 데이터를 담아서 보내주기 위해서 사용했습니다.
- 그리고 보안상 get보다는 post가 유리한 조건을 가지고 있다고 알고 있어 그렇게 저장했습니다.
- 아쉬운점: REST 원칙에 대해서 얘기햇더라면...

10. 200, 400, 500 의 의미를 아느냐
- 200은 성공을 의미합니다. 500 에러 코드는 보통 서버상의 오류가 발생했을 때 사용하는 코드이고, 400은 요청 데이터의 파라미터가 불일치 할 때 읃답하는 상태 코드입니다.
- 아쉬운점: 면접 끝나고 나서도 생각하지 못한 부분인데, controller 에서 사용하는 응답코드 기준이... 모호하긴 했었네요.. '성공한 실패' 사용한다고 설정해뒀던 걸 보고 질문하신 것 같습니다.
## 질문 + 나의 답변

1. HttpServletRequest request 에는 무엇이 있는가?
- jwt 토큰, 사용자의 ip 주소, 사용자가 보내는 데이터 request 데이터 같은 것들이... 들어있습니다.

2. @Component 어노테이션은 무엇인지 아느냐?
- Spring 에서 bean을 등록해줄 때 사용하는 어노테이션 입니다. new로 객체를 생성하는 대신에 미리 해당 객체를 만들어두고 재사용하기 위해 사용됩니다.

3. @Component 쓰는거랑 new를 쓰는거의 차이를 아느냐?
- new를 사용하게되면 사용자 요청이 들어올 때마다 새로운 객체를 만들어 실행되지만, bean으로 등록한 객체를 이용하게되면 해당 객체를 각 요청에서 재사용하고 멀티스레드에서 실행시켜준다고 알고있습니다.
- 아쉬운 점: 결국 생명주기 얘기만 하면 되는 문제인건데.. 너무 오랜만에 생각하다 보니 정확한 답변을 하지 못했던 것 같네요.

3. 토큰이 유효한지 어떻게 체크하는지 알고있느냐?
- jwt 토큰 비밀키를 이용해 사용자를 검증하고 있습니다. 그리고 access 토큰과 refresh 토큰을 이용해 사용자 인증을 확인합니다.
  (이건 면접관의 질문 의도와 다른 답이었다고 함. 어떤 코드에서 어떻게 체크하는지를 아는지 물어본 것이었음)

4. 토큰 유효시간은 어떻게 설정했느냐?
- private.properties 파일에서 access토큰은 1시간, refresh 토큰은 1주일로 설정해뒀습니다.

5. access 토큰은 왜 1시간으로 설정했느냐, refresh 토큰은 왜 1주일로 했느냐?
- 서비스를 이용하는 동안 사용자가 잠시 자리를 비울 수도 있고, 사용자 경험을 향상시키기 위해 1시간정도로 잡았습니다.
- refresh 토큰은 보안상 1주일로 설정해뒀습니다.

6. refresh 토큰이 1주일이면 안전한거냐? 1주일로 설정한 근거가 무엇이냐
- 너무 짧으면 사용자 경험이 떨어질 수 있고, 너무 길면 그래도 해킹 위험에 더 장시간 노출될 수 있어서..
- 아쉬운 점: 개선 방향을 제시하면 좋았을 텐데.. 예를 들면 블랙리스트 관리에 대해 얘기한다던지, refresh 토큰도 자주 갱신을 해주면 된다라는 식으로?

7. @AuthenticationPrincipal 이건 왜 api endpoint마다 입력해서 사용하느냐 (JWT Filter 에서 SecurityContext에 memberId를 이용해 DB에서 조회한 사용자 데이터를 넣어주고 있었음)
- db에 데이터를 저장할 때 실제 사용자임을 확인하기 위해 넣었습니다.

8. 굳이 필요 없어 보이는데 넣어둔 이유가 뭐냐, 어짜피 로그인 인증 받는데 굳이 이게 있을 필요가 있느냐
- 아무리 인증을 받았다고 하더라도.. 비즈니스 로직에서도 확인이 필요하지 않을까요...?
- 아쉬운 점: 지금 생각해보니 id도 들어오는데 굳이 db 조회를 다시 할 필요가 있나 싶다. (바로 코드 리팩토링 진행함)

9. 데이터 생성에 post 요청을 사용한 이유가 무엇이냐
- get으로도 요청을 보내는게 가능하긴 하지만, 데이터 생성에 있어서 긴 데이터를 저장하는 경우에 body에 데이터를 담아서 보내주기 위해서 사용했습니다.
- 그리고 보안상 get보다는 post가 유리한 조건을 가지고 있다고 알고 있어 그렇게 저장했습니다.
- 아쉬운점: REST 원칙에 대해서 얘기햇더라면...

10. 200, 400, 500 의 의미를 아느냐
- 200은 성공을 의미합니다. 500 에러 코드는 보통 서버상의 오류가 발생했을 때 사용하는 코드이고, 400은 요청 데이터의 파라미터가 불일치 할 때 읃답하는 상태 코드입니다.
- 아쉬운점: 면접 끝나고 나서도 생각하지 못한 부분인데, controller 에서 사용하는 응답코드 기준이... 모호하긴 했었네요.. '성공한 실패' 사용한다고 설정해뒀던 걸 보고 질문하신 것 같습니다.

</br></br>

GenieQ 개발 당시에는 내가 팀장을 맡아 팀원들의 코드를 리뷰했고,

천재교육 인턴십에서 GENIE 로 리팩토링을 진행하며 기술부채를 해소했었습니다.

인증방식도 spring security를 우회한 session 기반 인증방식을 JWT 를 이용한 stateless 방식을 채택했지만, 생각보다 많은 허점이 있다는 것을 이번 코드 리뷰를 통해 느낄 수 있었네요.

면접이 끝난 후 사용하지 않는 함수를 정리하고,

stateless 방식에서 계속 사용자를 조회하던 @AuthenticationPrincipal 패턴을 리팩토링하여 추가 개선을 진행하였습니다.

지금까지는 내가 다른 사람의 코드를 리뷰하거나, Ai 에게 코드 리뷰를 맡기기만 했었는데,

이렇게 면접을 통해 코드 리뷰를 체험하다보니 '내 코드'를 다시 훑어 보고, 다른 사람과 함께 코드 리뷰를 진행하는 것의 중요성을 느낄 수 있었네요.
정말 뜻 깊은 시간이었습니다.